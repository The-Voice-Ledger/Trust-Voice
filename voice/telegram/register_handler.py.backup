"""
Registration Handler
Handles new user registration with role-based flows

Flows:
1. Donor: Instant registration (no approval)
2. Campaign Creator: Multi-step form ‚Üí Admin approval
3. Field Agent: Multi-step form ‚Üí Admin approval
"""

import logging
from datetime import datetime
from typing import Optional
import os
from pathlib import Path

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardRemove
from telegram.ext import (
    ConversationHandler,
    CallbackQueryHandler,
    ContextTypes
)

from database.db import SessionLocal
from database.models import User, PendingRegistration, UserRole
from services.auth_service import hash_pin, is_weak_pin
from voice.telegram.session_manager import RegistrationSession
from voice.tasks.voice_tasks import process_voice_message_task

# Audio temp directory
AUDIO_TEMP_DIR = Path(__file__).parent.parent.parent / "uploads" / "audio"
AUDIO_TEMP_DIR.mkdir(parents=True, exist_ok=True)

logger = logging.getLogger(__name__)

# Conversation states
SELECTING_ROLE = 1
ENTERING_FULL_NAME = 2
ENTERING_ORG_NAME = 3
ENTERING_LOCATION = 4
ENTERING_PHONE = 5
ENTERING_REASON = 6
# Campaign Creator specific
ENTERING_VERIFICATION_EXP = 7
# Field Agent specific
ENTERING_COVERAGE_REGIONS = 8
ENTERING_GPS_PHONE = 9
# PIN setup
ENTERING_PIN = 10
CONFIRMING_PIN = 11
# Confirmation state for voice inputs
CONFIRMING_VOICE_INPUT = 12


async def register_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /register command - Start registration flow"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    logger.info(f"User {user.first_name} ({telegram_user_id}) started registration")
    
    # Check if already registered
    db = SessionLocal()
    try:
        existing_user = db.query(User).filter(
            User.telegram_user_id == telegram_user_id
        ).first()
        
        if existing_user:
            await update.message.reply_text(
                "‚úÖ You are already registered!\n\n"
                "Use /help to see what you can do."
            )
            return ConversationHandler.END
        
        # Check if pending registration exists
        pending = db.query(PendingRegistration).filter(
            PendingRegistration.telegram_user_id == telegram_user_id,
            PendingRegistration.status == "PENDING"
        ).first()
        
        if pending:
            await update.message.reply_text(
                "‚è≥ Your registration is pending admin approval.\n\n"
                f"Role requested: {pending.requested_role}\n"
                "We'll notify you once approved!"
            )
            return ConversationHandler.END
    finally:
        db.close()
    
    # Start new registration - Role selection
    message = (
        f"Welcome {user.first_name}! üé§\n\n"
        "TrustVoice connects donors with verified campaigns.\n\n"
        "Please select your role:"
    )
    
    keyboard = [
        [InlineKeyboardButton("üéÅ Donor - I want to donate", callback_data="role:DONOR")],
        [InlineKeyboardButton("üì¢ Campaign Creator - I need funding", callback_data="role:CAMPAIGN_CREATOR")],
        [InlineKeyboardButton("‚úÖ Field Agent - I verify campaigns", callback_data="role:FIELD_AGENT")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(message, reply_markup=reply_markup)
    
    # Initialize session
    session = RegistrationSession(telegram_user_id)
    session.set({
        "telegram_username": user.username,
        "telegram_first_name": user.first_name,
        "telegram_last_name": user.last_name,
        "step": "role_selection"
    })
    
    return SELECTING_ROLE


async def handle_role_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle role selection from inline button"""
    query = update.callback_query
    await query.answer()
    
    user = update.effective_user
    telegram_user_id = str(user.id)
    role_data = query.data.split(":")[1]  # Extract "DONOR", "CAMPAIGN_CREATOR", or "FIELD_AGENT"
    
    session = RegistrationSession(telegram_user_id)
    
    # Parse role
    if role_data == "DONOR":
        # DONOR: Instant registration
        db = SessionLocal()
        try:
            new_user = User(
                telegram_user_id=telegram_user_id,
                telegram_username=user.username,
                telegram_first_name=user.first_name,
                telegram_last_name=user.last_name,
                role=UserRole.DONOR,
                is_approved=True,
                approved_at=datetime.utcnow()
            )
            db.add(new_user)
            db.commit()
            
            logger.info(f"Donor registered: {telegram_user_id}")
            
            await query.edit_message_text(
                "‚úÖ Registration complete!\n\n"
                "As a donor, you can:\n"
                "üé§ Browse campaigns via voice\n"
                "üí∞ Make donations\n"
                "üìä Track your impact\n\n"
                "Try: \"Show me water projects in Ethiopia\""
            )
            
            session.delete()
            return ConversationHandler.END
            
        except Exception as e:
            logger.error(f"Donor registration failed: {e}")
            await query.edit_message_text(
                "‚ùå Registration failed. Please try again with /register"
            )
            session.delete()
            return ConversationHandler.END
        finally:
            db.close()
    
    elif role_data == "CAMPAIGN_CREATOR":
        # CAMPAIGN_CREATOR: Multi-step form
        session.update({"requested_role": "CAMPAIGN_CREATOR"})
        
        await query.edit_message_text(
            "üì¢ Campaign Creator Registration\n\n"
            "Your account requires admin approval.\n"
            "We'll ask a few questions to verify your identity.\n\n"
            "Step 1 of 7: What is your full name?"
        )
        
        return ENTERING_FULL_NAME
    
    elif role_data == "FIELD_AGENT":
        # FIELD_AGENT: Multi-step form
        session.update({"requested_role": "FIELD_AGENT"})
        
        await query.edit_message_text(
            "‚úÖ Field Agent Registration\n\n"
            "Your account requires admin approval.\n"
            "We'll ask a few questions to verify your credentials.\n\n"
            "Step 1 of 7: What is your full name?"
        )
        
        return ENTERING_FULL_NAME
    
    else:
        await query.edit_message_text("Invalid selection. Please use /register to try again.")
        return ConversationHandler.END


# Helper function to process voice
async def process_voice_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Optional[str]:
    """Process voice message and return transcribed text"""
    try:
        voice = update.message.voice
        file = await context.bot.get_file(voice.file_id)
        
        # Download voice file
        file_path = AUDIO_TEMP_DIR / f"{voice.file_id}.ogg"
        await file.download_to_drive(file_path)
        
        # Process with Celery task
        result = process_voice_message_task.delay(
            str(file_path),
            str(update.effective_user.id),
            "en"
        )
        
        # Wait for result (max 30 seconds)
        task_result = result.get(timeout=30)
        
        # Clean up
        if file_path.exists():
            file_path.unlink()
        
        return task_result.get("transcription")
        
    except Exception as e:
        logger.error(f"Voice processing failed: {e}")
        return None


# Multi-step form handlers
async def handle_full_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 2: Full name (TEXT ONLY)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    session.update({"full_name": update.message.text})
    
    await update.message.reply_text(
        "Step 2 of 7: What is your organization name?\n\n"
        "üé§ You can speak OR ‚å®Ô∏è type"
    )
    return ENTERING_ORG_NAME


async def handle_org_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 3: Organization name (VOICE OR TEXT)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    
    # Handle voice message
    if update.message.voice:
        transcription = await process_voice_input(update, context)
        if not transcription:
            await update.message.reply_text("‚ùå Couldn't process voice. Please try again or type:")
            return ENTERING_ORG_NAME
        
        # Store temporarily and ask for confirmation
        session.update({
            "temp_org_name": transcription,
            "pending_field": "organization_name"
        })
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ YES, correct", callback_data="confirm:yes")],
            [InlineKeyboardButton("‚ùå NO, try again", callback_data="confirm:no")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            f"I heard: *{transcription}*\n\nIs this correct?",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return CONFIRMING_VOICE_INPUT
    
    # Handle text message
    session.update({"organization_name": update.message.text})
    
    await update.message.reply_text(
        "Step 3 of 7: What is your location (city, country)?\n\n"
        "üé§ You can speak OR ‚å®Ô∏è type"
    
        
        return task_result.get("transcription")
        
    except Exception as e:
        logger.error(f"Voice processing failed: {e}")
        return None


# Multi-step form handl (VOICE OR TEXT)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    
    # Handle voice message
    if update.message.voice:
        transcription = await process_voice_input(update, context)
        if not transcription:
            await update.message.reply_text("‚ùå Couldn't process voice. Please try again or type:")
            return ENTERING_LOCATION
        
        session.update({
            "temp_location": transcription,
            "pending_field" (TEXT ONLY for accuracy)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    data = session.get()
    
    phone = update.message.text
    if phone.lower() in ["skip", "no", "none"]:
        phone = None
    
    session.update({"phone_number": phone})
    
    # Branch based on role
    requested_role = data.get("requested_role")
    
    if requested_role == "CAMPAIGN_CREATOR":
        await update.message.reply_text(
            "Step 5 of 7: Why do you need funding? Describe your campaign.\n\n"
            "üé§ You can speak (easier for long descriptions) OR ‚å®Ô∏è type"
        )
        return ENTERING_REASON
    
    elif requested_role == "FIELD_AGENT":
        await update.message.reply_text(
            "Step 5 of 7: Do you have experience verifying campaigns?\n\n"
            "üé§ You can speak OR ‚å®Ô∏è type7: What is your organization name?")
    return ENTERING_ORG_NAME


async def handle_org_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 3: Organization name"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession( (VOICE OR TEXT)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    
    # Handle voice message
    if update.message.voice:
        transcription = await process_voice_input(update, context)
        if not transcription:
            await update.message.reply_text("‚ùå Couldn't process voice. Please try again or type:")
            return ENTERING_REASON
        
        session.update({
            "temp_reason": transcription,
            "pending_field": "reason"
        })
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ YES, correct", callback_data="confirm:yes")],
            [InlineKeyboardButton("‚ùå NO, try again", callback_data="confirm:no")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            f"I heard:\n\n*{transcription}*\n\nIs this correct?",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return CONFIRMING_VOICE_INPUT
    
    # Handle text message
    session.update({"reason": update.message.text})
    
    await update.message.reply_text(
        "Step 6 of 7: Do you have experience with campaign verification?\n\n"
        "üé§ You can speak OR ‚å®Ô∏è type
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    session.update({"location": update.message.text})
    
    await update.message.reply_text(
        "Step 4 of 7: What is your phone number?\n"
        "(Optional - for identity verification)"
    )
    return ENTERING_PHONE
 (VOICE OR TEXT)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    data = session.get()
    
    # Handle voice message
    if update.message.voice:
        transcription = await process_voice_input(update, context)
        if not transcription:
            await update.message.reply_text("‚ùå Couldn't process voice. Please try again or type:")
            return ENTERING_VERIFICATION_EXP
        
        session.update({
            "temp_verification_experience": transcription,
            "pending_field": "verification_experience"
        })
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ YES, correct", callback_data="confirm:yes")],
            [InlineKeyboardButton("‚ùå NO, try again", callback_data="confirm:no")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            f"I heard:\n\n*{transcription}*\n\nIs this correct?",
            reply_markup=reply_markup,
            parse_mode="Markdown"VOICE OR TEXT - Field Agent only)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    
    # Handle voice message
    if update.message.voice:
        transcription = await process_voice_input(update, context)
        if not transcription:
            await update.message.reply_text("‚ùå Couldn't process voice. Please try again or type:")
            return ENTERING_COVERAGE_REGIONS
        
        session.update({
            "temp_coverage_regions": transcription,
            "pending_field": "coverage_regions"
        })
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ YES, correct", callback_data="confirm:yes")],
            [InlineKeyboardButton("‚ùå NO, try again", callback_data="confirm:no")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            f"I heard:\n\n*{transcription}*\n\nIs this correct?",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return CONFIRMING_VOICE_INPUT
    
    # Handle text message
    session.update({"verification_experience": update.message.text})
    
    requested_role = data.get("requested_role")
    
    if requested_role == "FIELD_AGENT":
        await update.message.reply_text(
            "Step 7 of 8: Which regions can you cover for verification?\n\n"
            "üé§ You can speak OR ‚å®Ô∏è type"
        )
        return ENTERING_COVERAGE_REGIONS
    else:
        # Campaign Creator - go to PIN
        await update.message.reply_text(
            "Step 7 of 7: ‚å®Ô∏è TYPEPAIGN_CREATOR":
        await update.message.reply_text(
            "Step 5 of 7: Why do you need funding? Describe your campaign.\n"
            "(Be specific about the problem you're solving)"
        )
        return ENTERING_REASON
    
    elif requested_role == "FIELD_AGENT":
        await update.message.reply_text(
            "Step 5 of 7: Do you have experience verifying campaigns or projects?\n"
            "Describe your relevant experience."
        )
        return ENTERING_VERIFICATION_EXP
    
    return ConversationHandler.END


# Campaign Creator specific
async def handle_reason(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 6: Reason for campaign"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    session.update({"reason": update.message.text})
    
    await update.message.reply_text(
        "Step 6 of 7: Do you have experience with campaign verification?\n"
        "(Have you worked with NGOs, donors, or verification systems?)"
    )
    return ENTERING_VERIFICATION_EXP


# Field Agent specific
async def handle_verification_exp(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 6: Verification experience"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    data = session.get()
    session.update({"verification_experience": update.message.text})
    
    requested_role = data.get("requested_role")
    
    if requested_role == "FIELD_AGENT":
        await update.message.reply_text(
            "Step 7 of 8: Which regions can you cover for verification?\n"
            "(List cities/regions where you can visit campaigns)"
        )
        return ENTERING_COVERAGE_REGIONS
    else:
        # Campaign Creator - go to PIN
        await update.message.reply_text(
            "Step 7 of 7: Set a 4-digit PIN for web access\n\n"
            "This PIN will let you access the web dashboard.\n"
            "‚ùå Don't use: 0000, 1234, 1111, etc.\n\n"
            "Enter your 4-digit PIN:"
        )
        return ENTERING_PIN


async def handle_coverage_regions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 7: Coverage regions (Field Agent only)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    session.update({"coverage_regions": update.message.text})
    
    keyboard = [
        [KeyboardButton("Yes, I have a smartphone with GPS")],
        [KeyboardButton("No, I don't have GPS")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    
    await update.message.reply_text(
        "Step 8 of 9: Do you have a smartphone with GPS?\n"
        "(GPS is required for location verification)",
        reply_markup=reply_markup
    )
    return ENTERING_GPS_PHONE


async def handle_gps_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Step 8: GPS phone (Field Agent only)"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    
    has_gps = "Yes" in update.message.text or "yes" in update.message.text
    session.update({"has_gps_phone": has_gps})
    
    await update.message.reply_text(
        "Step 9 of 9: Set a 4-digit PIN for verification tools\n\n"
        "This PIN will let you access verification features.\n"
        "‚ùå Don't use: 0000, 1234, 1111, etc.\n\n"
        "Enter your 4-digit PIN:",
        reply_markup=ReplyKeyboardRemove()
    )
    return ENTERING_PIN

# PIN setup
async def handle_pin_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle PIN entry"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    pin = update.message.text.strip()
    
    # Delete message for security
    try:
        await update.message.delete()
    except:
        pass
    
    # Validate PIN
    if not pin.isdigit() or len(pin) != 4:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ùå PIN must be exactly 4 digits. Try again:"
        )
        return ENTERING_PIN
    
    is_weak, reason = is_weak_pin(pin)
    if is_weak:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"‚ùå PIN is too weak ({reason}). Try again:"
        )
        return ENTERING_PIN
    
    # Store PIN temporarily
    session = RegistrationSession(telegram_user_id)
    session.update({"temp_pin": pin})
    
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Confirm your PIN (enter again):"
    )
    return CONFIRMING_PIN


async def handle_pin_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle PIN confirmation"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    pin_confirm = update.message.text.strip()
    
    # Delete message for security
    try:
        await update.message.delete()
    except:
        pass
    
    session = RegistrationSession(telegram_user_id)
    data = session.get()
    
    if not data:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ùå Session expired. Please start over with /register"
        )
        return ConversationHandler.END
    
    temp_pin = data.get("temp_pin")
    
    if pin_confirm != temp_pin:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ùå PINs don't match. Let's start PIN setup again.\n\nEnter your 4-digit PIN:"
        )
        session.update({"temp_pin": None})
        return ENTERING_PIN
    
    # Hash PIN
    pin_hash = hash_pin(temp_pin)
    
    # Save to pending_registrations
    db = SessionLocal()
    try:
        pending = PendingRegistration(
            telegram_user_id=telegram_user_id,
            telegram_username=data.get("telegram_username"),
            telegram_first_name=data.get("telegram_first_name"),
            telegram_last_name=data.get("telegram_last_name"),
            requested_role=data.get("requested_role"),
            full_name=data.get("full_name"),
            organization_name=data.get("organization_name"),
            location=data.get("location"),
            phone_number=data.get("phone_number"),
            reason=data.get("reason"),
            verification_experience=data.get("verification_experience"),
            coverage_regions=data.get("coverage_regions"),
            has_gps_phone=data.get("has_gps_phone"),
            pin_hash=pin_hash,
            status="PENDING"
        )
        db.add(pending)
        db.commit()
        
        logger.info(f"Pending registration created: {telegram_user_id} ({data.get('requested_role')})")
        
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=(
                "‚úÖ Registration submitted!\n\n"
                f"Role: {data.get('requested_role')}\n"
                "Status: Pending admin approval\n\n"
                "We'll notify you once your account is approved.\n"
                "This usually takes 24-48 hours."
            )
        )
        
        # TODO: Notify admins about new pending registration
        
        session.delete()
        return ConversationHandler.END
        
    except Exception as e:
        logger.error(f"Failed to save pending registration: {e}")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ùå Registration failed. Please try again with /register"
        )
        session.delete()
        return ConversationHandler.END
    finally:
        db.close()


async def cancel_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel registration"""
    user = update.effective_user
    telegram_user_id = str(user.id)
    
    session = RegistrationSession(telegram_user_id)
    session.delete()
    
    await update.message.reply_text(
        "Registration cancelled.\n\nYou can start again with /register",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END
